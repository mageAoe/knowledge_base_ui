import{_ as a,c as l,o as t,O as s}from"./chunks/framework.41379913.js";const P=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"interview/html/index.md"}'),e={name:"interview/html/index.md"},n=s(`<h2 id="html5语义化标签有哪些" tabindex="-1">HTML5语义化标签有哪些 <a class="header-anchor" href="#html5语义化标签有哪些" aria-label="Permalink to &quot;HTML5语义化标签有哪些&quot;">​</a></h2><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">头部</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">header</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">页脚</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">footer</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">section</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">部分</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">section</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">article</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">文章</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">article</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">nav</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">导航栏</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">nav</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">aside</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;">侧边栏</span><span style="color:#89DDFF;">&lt;/</span><span style="color:#F07178;">aside</span><span style="color:#89DDFF;">&gt;</span></span></code></pre></div><h2 id="浏览器-客户端-存储方式" tabindex="-1">浏览器（客户端）存储方式 <a class="header-anchor" href="#浏览器-客户端-存储方式" aria-label="Permalink to &quot;浏览器（客户端）存储方式&quot;">​</a></h2><p>cookie</p><p>localstorage</p><p>sessionstorage</p><h2 id="doctype-的作用" tabindex="-1">&lt;!DOCTYPE&gt;的作用 <a class="header-anchor" href="#doctype-的作用" aria-label="Permalink to &quot;&lt;!DOCTYPE&gt;的作用&quot;">​</a></h2><p>告诉浏览器用什么文档标准来解析这个文档</p><h2 id="常见的浏览器及其内核" tabindex="-1">常见的浏览器及其内核 <a class="header-anchor" href="#常见的浏览器及其内核" aria-label="Permalink to &quot;常见的浏览器及其内核&quot;">​</a></h2><table><thead><tr><th>浏览器</th><th>内核</th></tr></thead><tbody><tr><td>谷歌</td><td>Chromium/Blink(chrome)</td></tr><tr><td>火狐</td><td>Gecko(firefox)</td></tr><tr><td>IE</td><td>Trident</td></tr><tr><td>搜狐</td><td>webkit(Safari)</td></tr></tbody></table><h2 id="什么情况下会遇到跨域-描述一下前端常见处理跨域的几种方式" tabindex="-1">什么情况下会遇到跨域，描述一下前端常见处理跨域的几种方式 <a class="header-anchor" href="#什么情况下会遇到跨域-描述一下前端常见处理跨域的几种方式" aria-label="Permalink to &quot;什么情况下会遇到跨域，描述一下前端常见处理跨域的几种方式&quot;">​</a></h2><p>浏览器最核心，最基本的安全功能是同源策略。限制了一个源中加载文本或者脚本与其他源中资源的交互方式，当浏览器执行一个脚本时会检查是否同源，只有同源的脚本才会执行，如果不同源即为跨域。</p><p>Jsonp：原理就是利用了script标签不受同源策略的限制，在页面中动态插入了script，script标签的src属性就是后端api接口的地址，并且以get的方式将前端回调处理函数名称告诉后端，后端在响应请求时会将回调返还，并且将数据以参数的形式传递回去。</p><p>CORS：(跨域资源共享)是一种允许当前域的资源被其他域的脚本请求访问的机制。 当使用XMLHttpRequest发送请求时，浏览器如果发现违反了同源策略就会自动加上一个请求头:origin,后端在接受到请求后确定响应后会在Response Headers中加入一个属性:Access-Control-Allow-Origin,值就是发起请求的源地址，浏览器得到响应会进行判断Access-Control-Allow-Origin的值是否和当前的地址相同，只有匹配成功后才进行响应处理。现代浏览器中和移动端都支持CORS，IE下需要8+。</p><p>服务器跨域，服务器中转代理。前端向本地服务器发送请求，本地服务器代替前端再向服务器接口发送请求进行服务器间通信，本地服务器是个中转站的角色，再将响应的数据返回给前端</p><h2 id="web前端应该从哪些方面来优化网站性能" tabindex="-1">Web前端应该从哪些方面来优化网站性能 <a class="header-anchor" href="#web前端应该从哪些方面来优化网站性能" aria-label="Permalink to &quot;Web前端应该从哪些方面来优化网站性能&quot;">​</a></h2><p>减少页面体积，提升网络加载</p><p>静态资源压缩合并，（JS/css代码压缩合并，雪碧图） 静态资源缓存 使用CDN加载资源更快</p><p>优化页面渲染 css放在前面，js放后面 懒加载 减少dom操作</p><h2 id="说说get和post请求" tabindex="-1">说说get和post请求 <a class="header-anchor" href="#说说get和post请求" aria-label="Permalink to &quot;说说get和post请求&quot;">​</a></h2><ul><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST没有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li><li>GET参数通过URL传递，POST放在Request body中。</li><li>GET产生一个TCP数据包；POST产生两个TCP数据包。（对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据））</li></ul><h2 id="一个页面从输入-url-到页面加载完的过程中都发生了什么事情" tabindex="-1">一个页面从输入 URL 到页面加载完的过程中都发生了什么事情? <a class="header-anchor" href="#一个页面从输入-url-到页面加载完的过程中都发生了什么事情" aria-label="Permalink to &quot;一个页面从输入 URL 到页面加载完的过程中都发生了什么事情?&quot;">​</a></h2><p>加载过程：</p><ul><li>浏览器根据 DNS 服务器解析得到域名的 IP 地址</li><li>向这个 IP 的机器发送 HTTP 请求</li><li>服务器收到、处理并返回 HTTP 请求</li><li>浏览器得到返回内容</li></ul><p>渲染过程：</p><ul><li>根据 HTML 结构生成 DOM 树</li><li>根据 CSS 生成 CSSOM</li><li>将 DOM 和 CSSOM 整合形成 RenderTree</li><li>根据 RenderTree 开始渲染和展示</li><li>遇到<code>&lt;script&gt;</code>时，会执行并阻塞渲染</li></ul><h2 id="请描述tcp三次握手与四次挥手" tabindex="-1">请描述TCP三次握手与四次挥手？ <a class="header-anchor" href="#请描述tcp三次握手与四次挥手" aria-label="Permalink to &quot;请描述TCP三次握手与四次挥手？&quot;">​</a></h2><p>三次握手：</p><ul><li>A对B说：我的序号是x，我要向你请求连接；（第一次握手，发送SYN包，然后进入SYN-SEND状态）</li><li>B听到之后对A说：我的序号是y，期待你下一句序号是x+1的话（意思就是收到了序号为x的话，即ack=x+1），同意建立连接。（第二次握手，发送ACK-SYN包，然后进入SYN-RCVD状态）</li><li>A听到B说同意建立连接之后，对A说：与确认你同意与我连接（ack=y+1,ACK=1,seq=x+1）。（第三次握手，A已进入ESTABLISHED状态）</li><li>B听到A的确认之后，也进入ESTABLISHED状态。</li></ul><p>四次挥手：</p><ul><li>A与B交谈结束之后，A要结束此次会话，对B说：我要关闭连接了（seq=u,FIN=1）。（第一次挥手，A进入FIN-WAIT-1）</li><li>B收到A的消息后说：确认，你要关闭连接了。（seq=v,ack=u+1,ACK=1）（第二次挥手，B进入CLOSE-WAIT）</li><li>A收到B的确认后,等了一段时间，因为B可能还有话要对他说。（此时A进入FIN-WAIT-2）</li><li>B说完了他要说的话（只是可能还有话说）之后，对A说，我要关闭连接了。（seq=w, ack=u+1,FIN=1，ACK=1）(第三次挥手)</li><li>A收到B要结束连接的消息后说：已收到你要关闭连接的消息。（seq=u+1,ack=w+1,ACK=1）(第四次挥手，然后A进入CLOSED)</li><li>B收到A的确认后，也进入</li></ul><h2 id="tcp与udp的区别" tabindex="-1">TCP与UDP的区别 <a class="header-anchor" href="#tcp与udp的区别" aria-label="Permalink to &quot;TCP与UDP的区别&quot;">​</a></h2><p>TCP：传输控制协议 UDP：用户数据报协议</p><p>区别：</p><ul><li>TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接</li><li>TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付</li><li>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</li><li>每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</li><li>TCP首部开销20字节;UDP的首部开销小，只有8个字节</li><li>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道</li></ul><h2 id="http是什么" tabindex="-1">http是什么? <a class="header-anchor" href="#http是什么" aria-label="Permalink to &quot;http是什么?&quot;">​</a></h2><p>HTTP是hypertext transfer protocol（超文本传输协议）的简写，它是TCP/IP协议的一个应用层协议，用于定义WEB浏览器与WEB服务器之间交换数据的过程。客户端连上web服务器后，若想获得web服务器中的某个web资源，需遵守一定的通讯格式，HTTP协议用于定义客户端与web服务器通迅的格式。</p><h2 id="http与https的区别" tabindex="-1">http与https的区别 <a class="header-anchor" href="#http与https的区别" aria-label="Permalink to &quot;http与https的区别&quot;">​</a></h2><ul><li>为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ul><h2 id="重排-回流-和重绘是什么-什么情况下会触发重排和重绘。" tabindex="-1">重排（回流）和重绘是什么?什么情况下会触发重排和重绘。 <a class="header-anchor" href="#重排-回流-和重绘是什么-什么情况下会触发重排和重绘。" aria-label="Permalink to &quot;重排（回流）和重绘是什么?什么情况下会触发重排和重绘。&quot;">​</a></h2><p>浏览器会把HTML解析成DOM，把CSS解析成CSSOM，DOM和CSSOM合并就产生了Render Tree。有了RenderTree，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</p><ul><li><p>回流：当Render Tree中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p></li><li><p>重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p></li><li><p>触发重排和重绘：</p><pre><code>  页面首次渲染
  浏览器窗口大小发生改变
  元素尺寸或位置发生改变
  元素内容变化（文字数量或图片大小等等）
  元素字体大小变化
  添加或者删除可见的DOM元素
</code></pre></li><li><p>减少重回和重排：避免频繁的样式操作，最好一次性重写style，或者一次性更改class，避免频繁操作dom，对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</p></li></ul>`,42),o=[n];function p(i,r,c,h,d,D){return t(),l("div",null,o)}const u=a(e,[["render",p]]);export{P as __pageData,u as default};
